morphism is powerful, reﬂecting that two structures are essentially identical, and thus we may choose to work with either, depending on which is more convenient for the task in hand. The school has been inﬂuenced by the work of Polya and Lakatos. The former [Pol:57] advocated a style of problem solving characterized by ﬁrst considering an easier sub-problem, and considering several examples. This generally leads to a clearer insight into solving the main problem. Lakatos’s approach to mathematical discovery [Lak:76] is characterized by heuristic methods. A primitive conjecture 130 4 Software Engineering is proposed and if global counter-examples to the statement of the conjecture are discovered, then the corresponding hidden lemma for which this global counterex- ample is a local counter example is identiﬁed and added to the statement of the primitive conjecture. The process repeats, until no more global counterexamples are found. A skeptical view of absolute truth or certainty is inherent in this. Partial functions are the norm in VDM♣, and as in standard VDM, the problem is that recursively deﬁned functions may be undeﬁned, or fail to terminate for several of the arguments in their domain. The logic of partial functions (LPFs) is avoided, and instead care is taken with recursive deﬁnitions to ensure termination is achieved for each argument. This is achieved by ensuring that the recursive argument is strictly decreasing in each recursive invocation. The ⊥symbol is typically used in the Irish school to represent undeﬁned or unavailable or do not care. Academic and industrial projects have been conducted using the method of the Irish school, but at this stage tool support is limited. There are proof obligations to demonstrate that the operations preserve the invari- ant. Proof obligations require a mathematical proof by hand or a machine-assisted proof to verify that the invariant remains satisﬁed after the operation. 4.5.8 The Z Speciﬁcation Language Z is a formal speciﬁcation language founded on Zermelo set theory. It was devel- oped in the late 1970s and early 1980s by Jean-Raymond Abrial at the Programming Research Group at Oxford. It is used for the formal speciﬁcation of software and is a model-oriented approach. An explicit model of the state of an abstract machine is given, and the operations are deﬁned in terms of the effect that they have on the state. The main features of the language include a mathematical notation which is similar to VDM and the schema calculus. The latter is visually striking and consists essentially of boxes, with these boxes or schemas used to describe operations and states. The schema calculus enables schemas to be used as building blocks and com- bined with other schemas. The Z speciﬁcation language was published as an ISO standard (ISO/IEC 13568:2002) in 2002. The schema calculus is a powerful means of decomposing a speciﬁcation into smaller pieces or schemas. This decomposition helps to ensure that a Z speciﬁcation is highly readable, as each individual schema is small in size and self-contained. Exception handling may be addressed by deﬁning schemas for the exception cases, and then combining the exception schema with the original operation schema. Math- ematical data types are used to model the data in a system and these data types obey mathematical laws. These laws enable simpliﬁcation of expressions and are useful with proofs. Operations are deﬁned in a precondition/postcondition style. However, the pre- condition is implicitly deﬁned within the operation; i.e., it is not separated out as in standard VDM. Each operation has an associated proof obligation to ensure that if the precondition is true, then the operation preserves the system invariant. The ini- tial state itself is, of course, required to satisfy the system invariant. Postconditions 4.5 Formal Methods 131 employ a logical predicate which relates the pre-state to the post-state, the post- state of a variable being distinguished by priming, e.g., v′. Various conventions are employed within Z speciﬁcation, for example v? indicates that v is an input variable; v′ indicates that v is an output variable. The symbol  Op operation indicates that the operation Op does not affect the state, whereas the symbol  Op indicates that Op is an operation which affects the state. Many of the data types employed in Z have no counterpart in standard program- ming languages. It is therefore important to identify and describe the concrete data structures which ultimately will represent the abstract mathematical structures. As the concrete structures may differ from the abstract, the operations on the abstract data structures may need to be reﬁned to yield operations on the concrete data which yield equivalent results. For simple systems, direct reﬁnement (i.e., one step from
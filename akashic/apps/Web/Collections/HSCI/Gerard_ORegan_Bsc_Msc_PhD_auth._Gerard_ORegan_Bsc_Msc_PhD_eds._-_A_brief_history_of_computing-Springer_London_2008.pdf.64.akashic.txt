the grammar of the programming language. If the program is syntactically correct, then the compiler generates machine code that corresponds to what the programmer has written.31 The compiler must preserve the semantics of the language: i.e., a program’s syntax gives no information on the meaning of the program: this is given by the semantics of the programming language, and it is the role of the compiler to preserved the semantics of the language. In natural languages, it is possi- ble for sentences to be syntactically correct, but semantically meaningless.32 Similarly, in programming languages it is possible to write syntactically cor- rect programs that behave in quite a different way from the intentions of the programmer. The formal semantics of a language is given by a mathematical model that describes the possible computations described by the language. There are three main approaches to programming language semantic, and these are axiomatic semantics, operational semantics and denotational semantics (Table 3.2). 31 Of course, what the programmer has written may not be what the programmer had intended. 32 An example of a sentence in a natural language that is syntactically correct but semantically meaningless is “I will be here yesterday”. 100 3 Computer Programming Languages Table 3.2 Programming language semantics Approach Description Axiomatic Semantics Axiomatic semantics involves giving meaning to phrases of the language by describing the logical axioms that that apply to them. This is an approach that is based on mathematical logic, and employs pre and post condition assertions to specify what happens when the statement executes. The relationship between the initial assertion and the ﬁnal assertion essentially gives the semantics of the code. This approach is due to C.A.R. Hoare33 and appeared in his famous 1969 paper [Hor:69] “An axiomatic basis for computer programming”. The axiomatic approach is often used in proving program correctness. Another use of axiomatic semantics has been in using the assertions as program speciﬁcation from which the program code may be derived (to satisfy the speciﬁcation). Dijkstra [Dij:76] has argued for developing the program and its proof of correctness together. The basic form of axiomatic semantics is {P} S {Q}, and this states that if P is true before S is executed, then Q is true after S. Axiomatic semantics does not employ the concept of the state of the machine in giving meaning to programs. Operational Semantics The operational semantics for a programming language describes how a valid program is interpreted as sequences of computational steps. These sequences then deﬁne the meaning of the program. Operational semantics was developed by Gordon Plotkin [Plo:81], and is essentially a mathematical interpreter. However, operational semantics is more precise than an interpreter since it is deﬁned mathematically, and not based on the meaning of the language in which the interpreter is written. An abstract machine (SECD machine) may be deﬁned to give meaning to phrases, and this is done by describing the transitions they induce on states of the machine. Operational semantics may also be deﬁned using the lambda calculus. Denotational Semantics Denotational semantics (originally called mathematical semantics) provides meaning to programs in terms of mathematical objects such as integers, tuples and functions. It was developed by Christopher Strachey and Dana Scott at the Programming Research Group at Oxford, England in the mid-1960s, and their approach to semantics is known as the Scott-Strachey approach. Dana Scott’s contributions included the formulation of domain theory, and this allowed programs containing recursive functions and loops to be given a precise semantics. Each phrase in the language is translated into a mathematical object that is the denotation of the phrase. Denotational Semantics has been applied to language design and implementation. 3.8 Review Questions 1. Describe the ﬁve generations of programming languages. 2. Describe the early use of machine code including its advantages and disad- vantages. 3.9 Summary 101 3. Describe the early use of assembly languages including their advantages and disadvantages. 4. Describe the key features of Fortran and Cobol. 5. Describe the key features of Pascal and C. 6. Discuss the key features of object-oriented languages. 7. Discuss the similarities and differences between imperative programming lan- guages and functional programming languages. 8. Discuss the key features of logic programming languages. 9. Discuss the similarities and differences between syntax and semantics of pro- gramming languages. 10. Discuss the three main types of programming language semantics. 3.9 Summary This chapter considered the evolution of programming languages from the older machine languages, to the low-level assembly languages, to high-level program- ming languages and object-oriented languages, to functional and logic programming languages. Finally, the syntax and semantics of programming languages was con- sidered. The advantages of the machine-level programming languages were execution
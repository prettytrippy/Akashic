abstract speciﬁcation to implementation) may be possible; in more complex sys- tems, deferred reﬁnement is employed, where a sequence of increasingly concrete speciﬁcations are produced to yield the executable speciﬁcation eventually. Z has been successfully applied in industry, and one of its well-known successes is the CICS project at IBM Hursley in England. A more detailed account of Z is in [ORg:06, Wrd:92] 4.5.8.1 The B-Method The B-Technologies [McD:94] consist of three components: a method for soft- ware development, namely the B-Method; a supporting set of tools, namely, the B-Toolkit; and a generic program for symbol manipulation, namely, the B-Tool (from which the B-Toolkit is derived). The B-Method is a model-oriented approach and is closely related to the Z speciﬁcation language. The speciﬁcation language was developed by Jean-Raymond Abrial. Every construct in the method has a set theoretic counterpart, and the method is founded on Zermelo set theory. Each oper- ation has an explicit precondition, and an immediate proof obligation is that the precondition is stronger than the weakest precondition for the operation. One key purpose [McD:94] of the abstract machine in the B-Method is to pro- vide encapsulation of variables representing the state of the machine and operations which manipulate the state. Machines may refer to other machines, and a machine may be introduced as a reﬁnement of another machine. The abstract machines are speciﬁcation machines, reﬁnement machines, or implementable machines. The B- Method adopts a layered approach to design where the design is gradually made more concrete by a sequence of design layers. Each design layer is a reﬁnement that involves a more detailed implementation in terms of abstract machines of the previ- ous layer. The design reﬁnement ends when the ﬁnal layer is implemented purely in terms of library machines. Any reﬁnement of a machine by another has associated proof obligations, and proof is required to verify the validity of the reﬁnement step. Speciﬁcation animation of the Abstract Machine Notation (AMN) speciﬁcation is possible with the B-Toolkit, and this enables typical usage scenarios of the AMN speciﬁcation to be explored for requirements validation. This is, in effect, an early form of testing, and it may be used to demonstrate the presence or absence of 132 4 Software Engineering desirable or undesirable behavior. Veriﬁcation takes the form of a proof to demon- strate that the invariant is preserved when the operation is executed within its pre- condition, and this is performed on the AMN speciﬁcation with the B-Toolkit. The B-Toolkit provides several tools which support the B-Method, and these include syntax and type checking; speciﬁcation animation, proof obligation genera- tor, auto prover, proof assistor, and code generation. Thus, in theory, a complete for- mal development from initial speciﬁcation to ﬁnal implementation may be achieved, with every proof obligation justiﬁed, leading to a provably correct program. The B-Method and toolkit have been successfully applied in industrial applica- tions, and one of the projects to which they have been applied is the CICS project at IBM Hursley in the United Kingdom. The B-Method and Toolkit have been designed to support the complete software development process from speciﬁcation to code. The application of B to the CICS project is described in [Hoa:95], and the automated support provided has been cited as a major beneﬁt of the application of the B-Method and the B-Toolkit. 4.5.9 Propositional and Predicate Calculus Propositional calculus associates a truth-value with each proposition and is widely employed in mathematics and logic. There are a rich set of connectives employed in the calculus for truth functional operations, and these include A ⇒B, A ∧B, A ∨B which denote, respectively, the conditional of A and B, the conjunction of A and B, and the disjunction of A and B. A truth table may be constructed to show the results of these operations on the binary values of A and B. That is, A and B have the binary truth values of true and false, and the result of the truth functional operation is to yield a binary value. There are other logics that allow more than two truth values. These include, for example, the logic of partial functions which is a 3-valued logic. This logic allows a third truth value (the undeﬁned truth-value) for the proposition as well as the standard binary values of true and false.
that wp(S, R) = wpS(R) = Q′, and so wpS is a predicate transformer, i.e., it may 134 4 Software Engineering be regarded as a function on predicates. The weakest precondition is the precondi- tion that places the fewest constraints on the state than all of the other precondi- tions of (S, R). That is, all of the other preconditions are stronger than the weakest precondition. The notation Q{S}R is used to denote partial correctness and indicates that if execution of S commences in any state satisfying Q, and if execution terminates, then the ﬁnal state will satisfy R. Often, a predicate Q which is stronger than the weakest precondition wp(S, R) is employed, especially where the calculation of the weakest precondition is nontrivial. Thus, a stronger predicate Q such that Q ⇒ wp(S, R) is sometimes employed in these cases. There are many properties associated with the weakest preconditions, and these are used in practice to simplify expressions involving weakest preconditions, and in determining the weakest preconditions of various program commands, e.g., assign- ments, iterations, etc. These are discussed in more detail in [ORg:06]. Weakest pre- conditions are useful in developing a proof of correctness of a program in parallel with its development. An imperative program may be regarded as a predicate transformer. This is since a predicate P characterises the set of states in which the predicate P is true, and an imperative program may be regarded as a binary relation on states, which may be extended to a function F, leading to the Hoare triple P{F}Q. That is, the pro- gram F acts as a predicate transformer. The predicate P may be regarded as an input assertion, i.e., a Boolean expression which must be true before the program F is executed. The Boolean expression Q is the output assertion, and is true if the program F terminates, having commenced in a state satisfying P. 4.5.9.2 The Process Calculi The objectives of the process calculi [Hor:85] are to provide mathematical models which provide insight into the diverse issues involved in the speciﬁcation, design, and implementation of computer systems which continuously act and interact with their environment.These systems may be decomposed into sub-systems which inter- act with each other and their environment. The basic building block is the pro- cess, which is a mathematical abstraction of the interactions between a system and its environment. A process which lasts indeﬁnitely may be speciﬁed recursively. Processes may be assembled into systems, execute concurrently, or communicate with each other. Process communication may be synchronized, and this generally takes the form of a process outputting a message simultaneously to another process inputting a message. Resources may be shared among several processes. Process calculi enrich the understanding of communication and concurrency, and elegant formalisms such as CSP [Hor:85] and CCS [Mil:89] have been developed. These calculi obey a rich collection of mathematical laws. The expression (a?P) in CSP describes a process which ﬁrst engages in event a, and then behaves as process P. A recursive deﬁnition is written as (μX)• F(X) and an example of a simple chocolate vending machine is: 4.5 Formal Methods 135 VMS = μX : {coin, choc} • (coin?(choc?X)) The simple vending machine has an alphabet of two symbols, namely, coin and choc. The behaviour of the machine is that a coin is entered into the machine, and then a chocolate selected and provided. CSP processes use channels to communicate values with their environment, and input on channel c is denoted by (c?.x Px). This describes a process that accepts any value x on channel c, and then behaves as process Px. In contrast, (c!eP) deﬁnes a process which outputs the expression e on channel c and then behaves as process P. The -calculus is based on names. Communication between processes takes place between known channels, and the name of a channel may be passed over a channel. There is no distinction between channel names and data values in the -calculus, and this is a difference between it and CCS. The output of a value v on channel a is given by ¯av; i.e., output is a negative preﬁx. Input on a channel a is given by a(x), and is a positive preﬁx. Private links or restrictions are given by (x)P in the -calculus and P\x in CCS. 4.5.10 Finite State Machines Early work on ﬁnite state automata was published by Warren McCulloch and Walter Pitts, in 1943. They were neurophysiologists and their paper “A Logical Calculus
crete, until ultimately a speciﬁcation that may be transferred into code is reached. The RAISE toolset includes library tools for storing and retrieving modules, and translators from subsets of RSL into Ada and C++. The Speciﬁcation and Descriptive Language (SDL) was developed to allow the behavior of telecommunication systems to be described and speciﬁed. It may be used at several levels of abstraction, ranging from a very broad overview of a system to detailed design. The behavior of the system is considered as the combined behav- ior of the processes in the system, and the latter is considered to be an extended ﬁnite state machine, i.e., a ﬁnite state machine that can use and manipulate data stored in variables local to the machine. Processes may cooperate via signals (i.e., discrete messages) and exhibit deterministic behavior. A graphical language is employed to describe processes and this involves graphical representation of states, input, output, and decisions. Channels enable communication between blocks (containing processes) and the system (containing blocks connected by channels) and its environment. SDL supports time constraints via the timer construct. The graphical language has a corresponding equivalent textual representation. 4.5.13 Proof and Formal Methods The word proof has several connotations in various disciplines; for example, in a court of law, the defendant is assumed innocent until proven guilty. The proof of the guilt of the defendant may take the form of certain facts in relation to the movements of the defendant, the defendant’s circumstances, the defendant’s alibi, statements taken from witnesses, rebuttal arguments from the defense, and certain theories produced by the prosecution or defense. Ultimately, in the case of a trial by jury, the defendant is judged guilty or not guilty depending on the extent to which the jury has been convinced by the arguments made by the prosecution and defense. A mathematical proof typically includes natural language and mathematical sym- bols, and often many of the tedious details of the proof are omitted. The strategy of proof in proving a conjecture tends to be a divide and conquer technique; i.e., break- ing the conjecture down into subgoals and then attempting to prove the subgoals. Most proofs in formal methods are concerned with cross-checking on the details of the speciﬁcation or are concerned with checking the validity of reﬁnement steps, or 140 4 Software Engineering proofs that certain properties are satisﬁed by the speciﬁcation. There are often many tedious lemmas to be proved, and theorem provers31 are essential in assisting with this. Machine proof needs to be explicit, and reliance on some brilliant insight is avoided. Proofs by hand are notorious for containing errors or jumps in reasoning, as discussed in chapter one of [HB:95], while machine proofs are often extremely lengthy and unreadable. They generally help to avoid errors and jumps in reasoning, as every step in the proof needs to be justiﬁed. A mathematical proof consists of a sequence of formulae, where each element is either an axiom or derived from a previous element in the series by applying a ﬁxed set of mechanical rules. One well-known theorem prover is the Boyer/Moore theorem prover [BoM:85]. There is an interesting case in the literature concerning the proof of correctness of the VIPER microprocessor32 [Tie:91], and the actual machine proof consisted of several million formulae. Theorem provers are invaluable in resolving many of the thousands of proof obli- gations that arise from a formal speciﬁcation, and it is not feasible to apply formal methods in an industrial environment without the use of machine assisted proof. Automated theorem proving is difﬁcult, as often mathematicians prove a theorem with an initial intuitive feeling that the theorem is true. Human intervention to pro- vide guidance or intuition improves the effectiveness of the theorem prover. The proof of various properties about the programs increases conﬁdence in the correctness of the program. However, an absolute proof of correctness is unlikely except for the most trivial of programs. A program may consist of legacy soft- ware which is assumed to work, or be created by compilers which are assumed to work. Theorem provers are programs which are assumed to function correctly. Therefore, in order to be absolutely certain one would also need to verify the hard- ware, customized-off-the-shelf software, subcontractor software, compilers, legacy software, the theorem prover itself, and every single execution path that the software system will be used for. The best that formal methods can claim is increased conﬁ- dence in correctness of the software, rather than an absolute proof of correctness. 4.6 Software Inspections and Testing Software inspections and testing play a key role in building quality into software products and verifying that the products are of high quality. The Fagan Inspec- tion Methodology is a well-known software inspection methodology developed
The subscript operator “!” is employed for subscripting: For example: Nums = [5, 2, 4, 6] then Nums!0 is 5. The elements of a list are required to be of the same type. A sequence of elements that contains mixed types is called a tuple. A tuple is written as follows: Employee = (“Holmes”, “222 Baker St. London”, 50, “Detective”) A tuple is similar to a record in Pascal whereas lists are similar to arrays. Tuples cannot be subscripted but their elements may be extracted by pattern match- ing. Pattern matching is illustrated by the well-known example of the factorial function: fac 0 = 1 fac (n+1) = (n+1) * fac n The deﬁnition of the factorial function uses two equations, distinguished by the use of different patterns in the formal parameters. Another example of pattern matching is the reverse function on lists: reverse [] = [] reverse (a:x) = reverse x ++ [a] Miranda is a higher-order language, and it allows functions to be passed as param- eters and returned as results. Currying is allowed and this allows a function of n-arguments to be treated as n applications of a function with 1-argument. Func- tion application is left associative: i.e., f x y means (f x) y. That is, the result of applying the function f to x is a function, and this function is then applied to y. Every function of two or more arguments in Miranda is a higher-order function. 3.5.2 Lambda Calculus Lambda Calculus (λ-calculus) was designed by Alonzo Church in the 1930s to study computability. It is a formal system that may be used to study function deﬁnition, function application, parameter passing and recursion. Lambda calculus may be employed to deﬁne what a computable function is, and any computable function may be expressed and evaluated using the calculus. Church used lambda calculus in 1936 to give a negative answer to Hilbert’s Entscheidungs problem. The question of whether two lambda calculus expressions are equivalent cannot be solved by a general algorithm. 3.6 Logic Programming Languages 95 The lambda calculus is equivalent to the Turing machine formalism. How- ever, lambda calculus emphasises the use of transformation rules, whereas Turing machines are concerned with computability on primitive machines. Lambda calcu- lus consists of a small set of rules: r Alpha-conversion rule (α-conversion)23 r Beta-reduction rule (β-reduction)24 r Eta-conversion (η-conversion)25 Every expression in the λ-calculus stands for a function with a single argument. The argument of the function is itself a function with a single argument, and so on. The deﬁnition of a function is anonymous in the calculus. For example, the function that adds one to its argument is usually deﬁned as f (x) = x + 1. However, in λ-calculus the function is deﬁned as: λ x.x + 1 (or equivalently as λ z.z + 1) The name of the formal argument x is irrelevant and an equivalent deﬁnition of the function is λ z. z+1. The evaluation of a function f with respect to an argument (e.g. 3) is usually expressed by f (3). In λ-calculus this would be written as (λ x.x + 1)3, and this evaluates to 3+1 = 4. Function application is left associative: i.e., f x y = ( f x) y. A function of two variables is expressed in lambda calculus as a function of one argument which returns a function of one argument. This is known as currying and has been discussed earlier. For example, the function f (x, y) = x + y is written as λ x. λ y. x + y. This is often abbreviated to λ x y. x + y. λ-calculus is a simple mathematical system and its syntax is deﬁned as follows: <exp> ::= <identiﬁer> | λ <identiﬁer>.<exp> | --abstraction <exp> <exp> | --application ( <exp> ) λ-Calculus’s four lines of syntax plus conversion rules are sufﬁcient to deﬁne Booleans, integers, data structures and computations on them. It inspired Lisp and modern functional programming languages. 3.6 Logic Programming Languages Imperative programming languages such as Fortran, C, and Pascal require the pro- grammer to explicitly deﬁne an algorithm to solve the particular problem, and the 23 This essentially expresses that the names of bound variables is unimportant. 24 This essentially expresses the idea of function application.
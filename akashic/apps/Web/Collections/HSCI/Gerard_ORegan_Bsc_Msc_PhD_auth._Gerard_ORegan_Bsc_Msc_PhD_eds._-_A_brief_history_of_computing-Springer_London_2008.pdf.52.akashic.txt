the application system users. There are more sophisticated 4GLs that attempt to generate whole systems from speciﬁcations of screens and reports. A ﬁfth-generation programming language, or 5GL, is a programming language that is based around solving problems using constraints applied to the program, 3 Object-oriented programming was originally developed by Norwegian Research with Simula-67 in the late 1960s. 4 James Martin is a consultant and author and has written many books on information technology. He was an early promoter of fourth generation languages and has written extensively on CASE and on Rapid Application Development. There is a James Martin twenty-ﬁrst century school at Oxford. 76 3 Computer Programming Languages rather than using an algorithm written by the programmer. Fifth-generation lan- guages are designed to make the computer (rather than the programmer) solve the problem for you. The programmer only needs to be concerned with the speciﬁcation of the problem and the constraints to be satisﬁed, and does not need to be concerned with the algorithm or implementation details. These languages are mainly used for research purposes especially in the ﬁeld of artiﬁcial intelligence. Prolog is one of the best known ﬁfth generation languages, and it is a logic programming language. Early research on ﬁfth generation languages was encouraging, and it was pre- dicted that they would eventually replace all other languages. However, the task of deriving an efﬁcient algorithm from a set of constraints for a particular prob- lem is non-trivial. This step has not been successfully automated and still requires the insight of a human programmer. Fifth-generation languages are used mainly in academia. 3.2 Early Programming Languages One of the earliest programming languages developed was Plankalk¨ul. This high- level imperative programming language was developed by Konrad Zuse in 1946. Zuse was a German engineer who designed the Z1, Z2 and Z3 computers. The name “Plankalk¨ul” derives from “Plan” and “Kalk¨ul” (meaning calculus) and essentially means a calculus for a computing plan, or a calculus of programs. Plankalk¨ul is a relatively modern language, and this is surprising for a lan- guage developed in 1946. There were no compilers for programming languages in 1946, and physical rewiring of the machine were required. For example, the ENIAC needed to be rewired for every different problem. Plankalk¨ul employed data structures and Boolean algebra and included a mechanism to deﬁne more powerful data structures. Zuse demonstrated that the Plankalk¨ul language could be used to solve scientiﬁc and engineering problems, and he wrote several example programs including programs for sorting lists and searching a list for a particular entry. Zuse completed the deﬁnition of Plankalk¨ul in 1946, but as there was no compiler for the language it was not possible to execute any Plankalk¨ul programs. The lan- guage was ﬁnally published in 1972, and a compiler for the language was eventually developed in 2000 at the Free University of Berlin. The compiler was developed in Java for a subset of the Plankalk¨ul language, and the ﬁrst programs were run over 55 years after the conception of the language. The main features of Plankalk¨ul are: r It is a high-level language r Its fundamental data types are arrays and tuples of arrays r There is a While construct for iteration r Conditionals are addressed using guarded commands r There is no GOTO statement r Programs are non-recursive functions r Type of a variable is speciﬁed when it is used 3.3 Imperative Programming Languages 77 The main constructs of the language are variable assignment, arithmetical and logi- cal operations, guarded commands and while loops. There are also some list and set processing functions. 3.3 Imperative Programming Languages Imperative programming is a programming style that describes computation in terms of a program state, and statements that change the program state. The term “imperative” in a natural language such as English, is a command to carry out a speciﬁc instruction or action. Similarly, imperative programming consists of a set of commands to be executed on the computer, and is therefore concerned with how the program will be executed. The execution of an imperative command generally results in a change of state. Imperative programming languages are quite distinct from functional and logical programming languages. Functional programming languages, like Miranda, have no global state, and programs consist of mathematical functions that have no side affects. In other words, there is no change of state, and the variable x will have the same value later in the program as it does earlier. Logical programming languages, like Prolog, deﬁne what is to be computed, rather than how the computation is
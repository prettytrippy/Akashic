type of a stack involves the speciﬁcation of the properties of the abstract data type. However, the abstract data type is not explicitly deﬁned; i.e., only the properties are deﬁned. The speciﬁcation of the pop operation on a stack is given by axiomatic properties, for example, pop(push(s, x)) = s. Comment 4.2 (Axiomatic Approach) The property-oriented approach has the advantage that the implementer is not constrained to a particular choice of imple- mentation, and the only constraint is that the implementation must satisfy the stipu- lated properties. The emphasis is on the identiﬁcation and expression of the required properties of the system, and the actual representation or implementation issues are avoided. That is, the focus is on the speciﬁcation of the underlying behavior. Properties are typically stated using mathematical logic or higher-order logics, and mechanized theorem-proving techniques may be employed to prove results. One potential problem with the axiomatic approach is that the properties spec- iﬁed may not be satisﬁable in any implementation. Thus, whenever a “formal axiomatic theory” is developed a corresponding “model” of the theory must be identiﬁed, in order to ensure that the properties may be realized in practice. That is, when proposing a system that is to satisfy some set of properties, there is a need to prove that there is at least one system that will satisfy the set of properties. The model-oriented approach has an explicit model to start with and so this problem does not arise. A constructive approach is preferred by some groups in formal methods, and in this approach whenever existence is stipulated constructive existence is implied, where a direct example of the existence of an object can be exhibited, or an algo- rithm to produce the object within a ﬁnite time period exists. This is different from an existence proof, where it is known that there is a solution to a particular problem, but where there is no algorithm to construct the solution. 4.5.6 The Vienna Development Method VDM dates from work done by the IBM research laboratory in Vienna. The aim of this group was to specify the semantics of the PL/1 programming language. This was achieved by employing the Vienna Deﬁnition Language (VDL) and the group took an operational semantic approach. That is, the semantics of the language is deter- mined in terms of a hypothetical machine which interprets the programs of that lan- guage [BjJ:78, BjJ:82]. Later work led to the Vienna Development Method (VDM) with its speciﬁcation language, Meta IV. This concerned itself with the denotational semantics of programming languages; i.e., a mathematical object (set, function, etc.) is associated with each phrase of the language [BjJ:82]. The mathematical object is termed the denotation of the phrase. VDM is a model-oriented approach and this means that an explicit model of the state of an abstract machine is given, and operations are deﬁned in terms of 128 4 Software Engineering this state. Operations may act on the system state, taking inputs, and producing outputs as well as a new system state. Operations are deﬁned in a precondition and post-condition style. Each operation has an associated proof obligation to ensure that if the precondition is true, then the operation preserves the system invariant. The initial state itself is, of course, required to satisfy the system invariant. VDM uses keywords to distinguish different parts of the speciﬁcation, e.g., preconditions, post-conditions, as introduced by the keywords pre and post respectively. In keeping with the philosophy that formal methods speciﬁes what a system does as distinct from how, VDM employs post-conditions to stipulate the effect of the operation on the state. The previous state is then distinguished by employing hooked variables, e.g., v¬, and the postcondition speciﬁes the new state (deﬁned by a logical predicate relating the pre-state to the post-state) from the previous state. VDM is more than its speciﬁcation language Meta IV (called VDM-SL in the standardization of VDM), and it is, in fact, a software development method, with rules to verify the steps of development. The rules enable the executable speciﬁca- tion, i.e., the detailed code, to be obtained from the initial speciﬁcation via reﬁne- ment steps. Thus, we have a sequence S = S0, S1 , . . . , Sn = E of speciﬁcations, where S is the initial speciﬁcation, and E is the ﬁnal (executable) speciﬁcation.
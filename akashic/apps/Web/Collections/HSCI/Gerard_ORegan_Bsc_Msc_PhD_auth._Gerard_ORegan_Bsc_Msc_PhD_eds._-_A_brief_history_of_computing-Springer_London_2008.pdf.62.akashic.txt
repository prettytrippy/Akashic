25 This essentially expresses the idea that two functions are equal if and only if they give the same results for all arguments. 96 3 Computer Programming Languages program then executes the algorithm. Imperative languages are concerned with implementation details on how the problem will be solved. Logic programming languages, in contrast, describe what is to be done, rather than how it should be done. These languages are concerned with the statement of the problem to be solved, rather than how the problem will be solved. These programming languages use mathematical logic as a tool in the statement of the problem deﬁnition. Logic is a useful tool in developing a body of knowl- edge (or theory), and it allows rigorous mathematical deduction to derive further truths from the existing set of truths. The theory is built up from a small set of axioms or postulates and rules of inference are employed to derive further truths logically. The objective of logic programming is to employ mathematical logic to assist with computer programming. Many problems are naturally expressed as a theory, and the statement that a problem needs to be solved is often equivalent to determining if a new hypothesis is consistent with an existing theory. Logic provides a rigorous way to determine this, as it includes a rigorous process for conducting proof. Computation in logic programming is essentially logical deduction, and logic programming languages use ﬁrst-order26 predicate calculus. These languages employ theorem proving to derive a desired truth from an initial set of axioms. These proofs are constructive27 in that more than existence is demonstrated: in fact, an actual object that satisﬁes the constraints is produced. Logic programming speciﬁes the objects, the relationships between them and the constraints that must be satisﬁed for the problem. 1. The set of objects involved in the computation 2. The relationships that hold between the objects 3. The constraints for the particular problem. The language interpreter decides how to satisfy the particular constraints. Arti- ﬁcial Intelligence inﬂuenced the development of logic programming, and John McCarthy28 demonstrated that mathematical logic could be used for expressing knowledge. The ﬁrst logic programming language was Planner, and this lan- guage was designed by Carl Hewitt at MIT in 1969. Planner uses a procedu- ral approach for knowledge representation rather than McCarthy’s approach of expressing knowledge using mathematical logic. The language allows theorem proving. 26 First-order logic allows quantiﬁcation over objects but not functions or relations. Higher-order logics allow quantiﬁcation of functions and relations. 27 For example, the statement ∃x such that x = √4 states that there is an x such that x is the square root of 4, and the constructive existence yields that the answer is that x = 2 or x = –2 i.e., constructive existence provides more the truth of the statement of existence, and an actual object satisfying the existence criteria is explicitly produced. 28 John McCarthy received the Turing Award in 1971 for his contributions to Artiﬁcial Intelligence. He also developed the programming language LISP. 3.6 Logic Programming Languages 97 The best known logic programming languages is Prolog, and this language was developed in the early 1970s by Alain Colmerauer and Robert Kowalski. It stands for programming in logic. It is a goal-oriented language that is based on predicate logic. Prolog became an ISO standard in 1995. The language attempts to solve a goal by tackling the sub-goals that the goal consists of: goal :- subgoal1, ..., subgoaln. which states that in order to prove a particular goal, it is sufﬁcient to prove subgoal1 through subgoaln. Each line of a typical Prolog program consists of a rule or a fact, and the language speciﬁes what exists rather than how. The following program fragment has one rule and two facts: grandmother(G,S) :- parent(P,S), mother(G,P). mother(sarah, issac). parent(issac, jacob). The ﬁrst line in the program fragment is a rule that states that G is the grandmother of S if there is a parent P of S and G is the mother of P. The next two statements are facts stating that issac is a parent of jacob, and that sarah is the mother of issac. A particular goal clause is true if all of its subclauses are true: goalclause(Vg) :- clause1(V1),..,clausem(Vm) A Horn clause consists of a goal clause and a set of clauses that must be proven separately. Prolog ﬁnds solutions by uniﬁcation: i.e., by binding a variable to a value. For an implication to succeed, all goal variables Vg on the left side of :- must ﬁnd a solution by binding variables from the clauses which are activated on the right side.
speed and efﬁciency. It was difﬁcult to write programs in these languages as the statements in the language are just a stream of binary numbers. Further, these lan- guages were not portable, as the machine language for one computer could differ signiﬁcantly from the machine language of another. The second generation languages, or 2GL, are low-level assembly languages that are speciﬁc to a particular computer and processor. These are easier to write and understand. They must be converted into the actual machine code to run on the computer. The assembly language is speciﬁc to a particular processor family and environment, and is therefore not portable. However, their advantages are execu- tion speed, as the assembly language is the native language of the processor, and compilation. The third generation languages, or 3GL, are high-level programming languages. They are general purpose languages and have been applied to business, scientiﬁc and general applications. They are designed to be easier for a human to understand and to allow the programmer to focus on problem solving. Their advantages include ease of readability, portability, and ease of debugging and maintenance. The early 3GLs were procedure-oriented and the later 3GLs were object-oriented. Fourth-generation languages, or 4GLs, are languages that consist of statements similar to human language. Most fourth generation languages are non-procedural, 33 Hoare was inﬂuenced by earlier work by Floyd on assigning meanings to programs using ﬂowcharts [Flo:67]. 102 3 Computer Programming Languages and are often used in database programming. They specify what needs to be done rather than how it should be done. Fifth-generation programming languages or 5GLs, are programming languages that is based around solving problems using logic programming or applying con- straints to the program. They are designed to make the computer (rather than the programmer) solve the problem. The programmer only needs to be concerned with the speciﬁcation of the problem and the constraints to be satisﬁed, and does not need to be concerned with the algorithm or implementation details. These languages are used mainly in academic environments. Chapter 4 Software Engineering Key Topics Birth of Software Engineering Floyd Hoare VDM and Z Cleanroom and Software Reliability Software Inspections and Testing Project Management Software Process Maturity Models 4.1 Introduction The NATO Science Committee organized two famous conferences on software engi- neering in the late 1960s. The ﬁrst conference was held in Garmisch, Germany, in 1968 and this was followed by a second conference in Rome in 1969. The Garmisch conference was attended by over 50 people from 11 countries including the eminent Dutch computer scientist, Edger Djkstra (Fig. 4.1). The NATO conferences highlighted the problems that existed in the software sector in the late 1960s, and the term software crisis was coined to refer to the prob- lems associated with software projects. These included budget and schedule over- runs, and problems with the quality and reliability of the delivered software. This led to the birth of software engineering as a separate discipline, and the realization that programming is quite distinct from science and mathematics. Programmers are like engineers in the sense that they build products; however, programmers are not educated as traditional engineers as they receive minimal education in design and mathematics.1 1 Software Companies that are following approaches such as the CMM or ISO 9000:2000 consider the qualiﬁcation of staff before assigning staff to performing speciﬁc tasks. The approach adopted 103 104 4 Software Engineering Fig. 4.1 Edsger Dijkstra at NATO Conference Courtesy of Brian Randell. The construction of bridges was problematic in the nineteenth century, and many people who presented themselves as qualiﬁed to design and construct bridges did not have the required knowledge and expertise. Consequently, many bridges collapsed, endangering the lives of the public. This led to legislation requiring an engineer to be licensed by the Professional Engineering Association prior to practicing as an engineer. These engineering associations identify a core body of knowledge that the engineer is required to possess, and the licensing body veriﬁes that the engineer has the required qualiﬁcations and experience. The licensing of engineers by most branches of engineering ensures that only personnel competent to design and build is that the appropriate qualiﬁcations and experience for the role are considered prior to appointing a person to carry out a particular role. My experience is that the more mature companies place signif- icant emphasis on the education and continuous development of their staff, and on introducing best practice in software engineering into their organization. I have observed an increasing trend among companies to mature their software processes to enable them to deliver superiour results. One of the purposes that the original CMM served was to enable the United States Department of Defence
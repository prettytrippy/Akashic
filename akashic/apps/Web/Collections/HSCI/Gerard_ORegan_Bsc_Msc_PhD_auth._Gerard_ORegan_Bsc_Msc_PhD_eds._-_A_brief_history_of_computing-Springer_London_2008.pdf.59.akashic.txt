commanded to speak this may result in a Moo, whereas if a Cat is commanded to speak this may result in a Meow. That is, a different response is given depending on the object to which it is applied. One key difference between C++ and C is the concept of a class. A class was explained in Table 3.1 and it is an extension to the C concept of a structure. The main difference is that a C data structure can hold only data, whereas a C++ class may hold both data and functions. An object is an instantiation of a class: i.e., the class is essentially the type, whereas the object is essentially the variable of that type. Classes are deﬁned in C++ by using the keyword class as follows: class class_name { access_specifier_1: member1; access_specifier_2: member2; ... } The members may be either data or function declarations, and an access speciﬁer is included to specify the access rights for each member (e.g., private, public or protected). Private members of a class are accessible only by other members of the same class;17 public members are accessible from anywhere where the object is visible; protected are accessible by other members of same class and also from members of their derived classes. This is illustrated in the example of the deﬁnition of the class rectangle: class CRectangle { int x, y; public: void set_values (int,int); int area (void); } rect; 17 It is also possible to deﬁne friendship among classes and private members are also accessible by friends. 3.5 Functional Programming Languages 91 Java is an object-oriented programming language developed by James Gosling and others at Sun Microsystems in the early 1990s. The syntax of the language was inﬂuenced by C and C++. The language was designed with portability in mind, and the objective is to allow a program to be written once and executed anywhere. Platform independence is achieved by compiling the Java code into Java bytecode. The latter is simpliﬁed machine instructions speciﬁc to the Java platform. This code is then run on a Java Virtual Machine (JVM) that interprets and exe- cutes the Java bytecode. The JVM is speciﬁc to the native code on the host hardware. The problem with interpreting bytecode is that it is slow compared to traditional compilation. However, Java has a number of techniques to address this including just in time compilation and dynamic recompilation. Java also provides automatic garbage collection. This is a very useful feature as it protects programmers who forget to deallocate memory (thereby causing memory leaks). Java is a proprietary standard that is controlled through the Java Community Pro- cess. Sun Microsystems makes most of its Java implementations available without charge. The following is an example of the Hello World program written in Java. class HelloWorld { public static void main (String args[]) { System.out.println ("Hello World!"); } } 3.5 Functional Programming Languages Functional programming is quite distinct from imperative programming in that com- putation for functional programs involves the evaluation of mathematical functions. Imperative programming, in contrast, involves the execution of sequential (or iter- ative) commands that change the system state. The assignment statement alters the value of a variable. That is, the variable x may represent 2 at one point in program execution, and following the Pascal assignment statement x := 3 (i.e., x is assigned to 3), the value of x changes and is now 3. In other words, for an imperative program, the value of a variable x may change during program execution. There are no side effects or changes of state for functional programs. The fact that the value of x will always be the same makes it easier to reason about func- tional programs than imperative programs, as the latter contain side affects. Func- tional programming languages provide referential transparency: i.e., equals may be substituted for equals, and if two expressions have equal values, then one can be substituted for the other in any larger expression without affecting the result of the computation. This makes it easier to reason about functional programs. 92 3 Computer Programming Languages Functional programming languages use higher-order functions,18 recursion, lazy and eager evaluation, monads,19 and Hindley-Milner type inference systems.20 These languages have mainly been used in academia, but there has been some industrial use, including the use of Erlang for concurrent applications in industry. The roots of functional programming languages are in the Lambda calculus devel- oped by Church in the 1930s. Lambda calculus provides an abstract framework for describing mathematical functions and their evaluation. Church employed lambda calculus to prove that there is no solution to the decision problem for ﬁrst order arithmetic in 1936. That is, he proved that there is no general algorithm which decides whether a given statement in ﬁrst order arithmetic is true or false.
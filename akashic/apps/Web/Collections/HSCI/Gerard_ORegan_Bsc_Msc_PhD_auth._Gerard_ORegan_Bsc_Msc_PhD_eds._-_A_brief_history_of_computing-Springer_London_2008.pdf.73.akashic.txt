as well as the proof of properties of the speciﬁcation. This abstraction away from implementation enables questions about what the system does to be answered inde- pendently of the implementation, i.e., the detailed code. Furthermore, the unam- biguous nature of mathematical notation avoids the problem of speculation about the meaning of phrases in an imprecisely worded natural language description of a system. Natural language is inherently ambiguous and subject to these limitations, whereas mathematics employs a precise notation with sound rules of inference. Spivey [Spi:92] deﬁnes formal speciﬁcation as: Deﬁnition 4.3 (Formal Speciﬁcation) Formal speciﬁcation is the use of mathe- matical notation to describe in a precise way the properties which an information system must have, without unduly constraining the way in which these properties are achieved. The formal speciﬁcation thus becomes the key reference point for the different parties concerned with the construction of the system. This includes determining customer needs, program implementation, testing of results, and program documen- tation. It follows that the formal speciﬁcation is a valuable means of promoting a common understanding for all those concerned with the system. The term formal methods is used to describe a formal speciﬁcation language and a method for the design and implementation of computer systems. The speciﬁcation is written in a mathematical language, and the implementa- tion is derived from the speciﬁcation via step-wise reﬁnement.14 The reﬁnement step makes the speciﬁcation more concrete and closer to the actual implementation. There is an associated proof obligation that the reﬁnement is valid, and that the con- crete state preserves the properties of the more abstract state. Thus, assuming that the original speciﬁcation is correct and the proofs of correctness of each reﬁnement step are valid, then there is a very high degree of conﬁdence in the correctness of the implemented software. Step-wise reﬁnement is illustrated as follows: the initial speciﬁcation S is the initial model M0, it is then reﬁned into the more concrete model M1, and M1 is then reﬁned into M2, and so on until the eventual implementation Mn = E is produced. 14 It is questionable whether step-wise reﬁnement is cost effective in mainstream software engi- neering, as it involves re-writing a speciﬁcation ad nauseum. It is time-consuming to proceed in reﬁnement steps with signiﬁcant time also required to prove that the reﬁnement step is valid. For safety-critical applications the main driver is quality and correctness rather than time. However, in mainstream software engineering often time to market is a key driver with a ﬁne balance necessary between time and quality. 4.5 Formal Methods 119 S = M0 ⊆M1 ⊆M2 ⊆M3 ⊆. . . . . . .. ⊆Mn = E Requirements are the foundation from which the system is built, and irrespective of the best design and development practices, the product will be incorrect if the requirements are incorrect. The objective of requirements validation is to ensure that the requirements are correct and reﬂect what is actually required by the customer (in order to build the right system). Formal methods may be employed to model the requirements, and the model exploration yields further desirable or undesirable properties. The ability to prove that certain properties are true of the speciﬁcation is very valuable, especially in safety critical and security critical applications. These properties are logical consequences of the deﬁnition of the requirements, and, if appropriate, the requirements may need to be amended appropriately. Thus, formal methods may be employed for requirements validation and in a sense to debug the requirements. The use of formal methods generally leads to more robust software and to increased conﬁdence in the correctness of the software. The challenges involved in the deployment of formal methods in an organization include the education of staff in formal speciﬁcation, as formal speciﬁcation and the use of mathematical techniques may be a culture shock to many staff. Formal methods have been applied to a diverse range of applications, includ- ing circuit design, artiﬁcial intelligence, the security critical ﬁeld, the safety critical ﬁeld, the railway sector, microprocessor veriﬁcation, the speciﬁcation of standards, and the speciﬁcation and veriﬁcation of programs. Formal methods have been criticized by Parnas and others on the following grounds (Table 4.3). However, formal methods are potentially quite useful in software engineering. The use of a method such as Z or VDM forces the engineer to be precise and helps to
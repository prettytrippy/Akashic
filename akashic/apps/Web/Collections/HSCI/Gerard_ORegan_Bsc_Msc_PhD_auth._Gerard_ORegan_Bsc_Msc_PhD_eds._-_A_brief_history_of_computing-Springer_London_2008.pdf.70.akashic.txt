ing documents are precise enough to allow systematic analysis to be carried out, whereas since software documents employ natural language rather than mathemat- ics. Parnas argues that only limited technical evaluation may take place on standard software engineering documents. He argues that if software engineers are to per- form as engineers then the software documents should be similar to engineering documents, and should include sufﬁcient mathematics to allow rigorous analysis to be performed. However, formal software inspections by engineers generate good results on documents that have been written in natural language, and help in ensur- ing that the document is ﬁt for purpose. The analysis of traditional engineering documents uses mathematics to verify that the design is correct. 4.3 Early Software Engineering Robert Floyd and others did pioneering work on software engineering in the 1960s. Floyd made valuable contributions to the theory of parsing, the semantics of pro- gramming languages, program veriﬁcation, and methodologies for the creation of efﬁcient and reliable software. He was born in New York in 1936, and attended the university of Chicago. He became a computer operator in the early 1960s, and commenced publishing papers in computer science. He was appointed associate professor at Carnegie Mellow University in 1963 and became a full professor of 4.3 Early Software Engineering 113 computer science at Sanford University in 1969. Knuth remarked that although Floyd never actually obtained a Ph.D. that several of his papers were better than any Ph.D. thesis that he saw. Floyd did pioneering work on mathematical techniques to verify program cor- rectness. Mathematics and Computer Science were regarded as two completely sep- arate disciplines in the 1960s, and the accepted approach to software development at that time was based on the assumption that the completed code would always contain defects. It was therefore better and more productive to write the code as quickly as possible, and to then perform various tests to ﬁnd the defects. Program- mers then corrected the defects, made patches and re-tested and found more defects. This continued until they could no longer ﬁnd defects. Of course, there was always the danger that defects remained in the code that could give rise to software failures. Floyd believed that there was a way to construct a rigorous proof of the correct- ness of the programs using mathematics, and that the disciplines of mathematics and computer science were related. Floyd showed that mathematics could be used for program veriﬁcation, and he introduced the concept of assertions that provided programmers with a way to verify the correctness of their programs. Flowcharts were employed in the 1960s to explain the sequence of basic steps for computer programs. Floyd’s insight was to build upon ﬂowcharts and to apply an invariant assertion to each branch in the ﬂowchart. These assertions state the essential relations that exist between the variables at that point in the ﬂow chart. It involves applying relations such as “R = Z > 0, X = 1, Y = 0”, to each branch in the ﬂowchart. Floyd also provided a general ﬂowchart language to apply his method to programming languages. The language essentially contains boxes linked by ﬂow of control arrows [Flo:67]. For example, if the assertion Q is true on entry to a branch where the condition at the branch is P. Then, the assertion on exit from the branch is Q ∧¬ P if P is false and Q ∧P otherwise (Fig. 4.6). Another example of the use of assertions is that of the assignment statement. Suppose x represents a variable and v represents a vector consisting of all the vari- ables in the program. Suppose f (x, v) represents a function or expression of x and the other program variables represented by the vector v. Suppose the assertion S( f (x, v), v) is true before the assignment x = f (x, v). Then the assertion S(x, v) is true after the assignment. This is represented in Floyd’s ﬂowcharts in Fig. 4.7. Fig. 4.6 Branch assertions in ﬂowcharts P N Y Q ∧¬ P Q Q ∧P 114 4 Software Engineering Fig. 4.7 Assignment assertions in ﬂowcharts S (  f(x,v), v) x = f(x,v)  S (x,v) Fig. 4.8 Entry and exit in ﬂowcharts Exit Entry Floyd used ﬂowchart symbols to represent entry and exit to the ﬂowchart. This included entry and exit assertions to describe the program’s entry and exit condi- tions. These are deﬁned in Fig. 4.8. Floyd’s technique shows the relationship between computer programs and a series of logical assertions. Each assertion is true whenever control passes to it. Statements in the programming language appear between the assertions. The initial
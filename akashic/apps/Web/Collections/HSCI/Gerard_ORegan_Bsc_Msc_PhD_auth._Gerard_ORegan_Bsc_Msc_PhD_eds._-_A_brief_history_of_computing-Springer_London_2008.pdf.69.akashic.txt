number of spirals, where each spiral typically involves updates to the requirements, design, code, testing, and a user review of the particular iteration or spiral. The spiral is, in effect, a re-usable prototype and the customer examines the cur- rent iteration and provides ‘feedback to the development team to be included in the next spiral. This approach is often used in joint application development for web- based software development. The approach is to partially implement the system. This leads to a better understanding of the requirements of the system and it then feeds into the next cycle in the spiral. The process repeats until the requirements and product are fully complete. There are other life-cycle models, for example, the iterative development process which combines the waterfall and spiral lifecycle model. The cleanroom approach Plan /  Reqs / DB Design   Reqs / Design Reqs / Design Reqs / Design Code/revie Test User  Test Test User  User  Code/revie Code/revie Customer Acceptanc Implementati on / Cleanup Reqs / Design Fig. 4.4 Spiral lifecycle model 4.2 What Is Software Engineering? 111 Estimation Accuracy - 1998 0 10 20 30 40 Estimation Accuracy Range Frequency Under 20% over 21% to 50% over 51% to 100% over 101% to 200% over Fig. 4.5 Standish group report – estimation accuracy to software development includes a phase for formal speciﬁcation and its approach to testing is quite distinct from other models as it is based on the predicted usage of the software product. Finally, the Rational Uniﬁed Process (RUP) has become popular in recent years. The challenge in software engineering is to deliver high-quality software on time to customers. The Standish Group research [ORg:02] (Fig. 4.5) on project cost over- runs in the United States during 1998 indicate that 33% of projects are between 21% and 50% over estimate, 18% are between 51% and 100% over estimate, and 11% of projects are between 101% and 200% overestimate. Project management and estimating project cost and schedule accurately are key software engineering challenges. Consequently, organizations need to deter- mine how good their estimation process actually is and to make improvements as appropriate. The use of software metrics is one mechanism to determine the current effectiveness of software estimation. This involves computing the variance between actual project effort and estimated project estimate, and actual project schedule versus projected project schedule. Risk management is a key part of project man- agement, and its objective is to identify potential risks to the project; determine the probability of the risks occurring; assessing the impact of each risk if it materializes; identifying actions to eliminate the risk or to reduce the probability of it occurring or its impact should it occur; contingency plans in place to address the risk if it materializes; and ﬁnally to track and manage the risks throughout the project. The concept of process maturity has become popular with the Capability Matu- rity Model, and organizations such as the SEI have collected empirical data to sug- gest that there is a close relationship between software process maturity and the quality and the reliability of the delivered software. However, the main focus of the CMM is management and organization practices rather than on the technical engineering practices. However, there are software engineering practices at matu- rity level 3 in the model. The use of the CMMI does provide a good engineering approach, as it does place strict requirements on what processes a company needs to have in place to provide a good engineering solution. This includes: 112 4 Software Engineering r Developing and managing requirements r Doing effective design r Planning and tracking projects r Building quality into the product with peer reviews r Performing rigourous testing r Performing independent audits There has been a growth of popularity among software developers in light-weight methodologies such as XP [Bec:00]. These methodologies view documentation with distaste, and often software development commences prior to the full speciﬁcation of the requirements. Classical engineering places emphasis on detailed planning and design and includes appropriate documentation. The design documents are analyzed and reviewed and used as a reference during the construction. Documentation is pro- duced in the software sector with varying degrees of success. The popularity of a methodology such as XP suggests developer antipathy to documentation. However, the more mature companies recognize the value of software documentation, and regard documentation as essential for all phases of the project. It is essential that the documentation is kept up to date and reﬂects the actual system since the impact of any changes requested to the software during maintenance cannot be properly determined. The empirical evidence suggests that software documentation is sometimes out of date. The difference between traditional engineering documents and standard software documents (e.g., documentation following the IEEE templates) is that engineer-
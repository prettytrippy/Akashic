read and written more easily by a human. They require considerably more program- ming effort than high-level programming languages, and they are more difﬁcult to use for larger applications. The assembly code must be converted into the actual machine code in order to run on the computer. The conversion of the assembly code to the machine code is simply a mapping of the assembly language code into the binary machine code (i.e., the ﬁrst generation language). The assembly language is speciﬁc to a particular processor family and environment, and it is therefore not portable. A program written in assembly language for a particular processor family needs to be re-written for a different platform. However, since the assembly language is in the native language of the processor it has signiﬁcant speed advantages over high- level languages. Second generation languages are still used today, but they have generally been replaced by high-level programming languages. The third generation languages, or 3GL, are high-level programming languages such as Pascal, C or Fortran. They are general purpose languages and have been applied to business, scientiﬁc and general applications. They are designed to be easier for a human to understand and include features such as named variables, con- ditional statements, iterative statements, assignment statements, and data structures. Early examples of third generation languages are Fortran, ALGOL and COBOL. Later examples are languages such as C, C++ and Java. The advantages of these high-level languages over the older second generation languages were: r Ease of readability r Clearly deﬁned syntax (and semantics2) 1 This is true of code generated by native compilers. Other compilers may compile the source code to the object code of a Virtual Machine, and the translator module of the Virtual Machine translates each byte code of the Virtual Machine to the corresponding native machine instruction. That is, the Virtual Machine translates each generalised machine instruction into a speciﬁc machine instruction (or instructions) that may then be executed by the processor on the target computer. Most computer languages such as C require a separate compiler for each computer platform (i.e., computer and operating system). However, a language such as Java comes with a virtual machine for each platform. This allows the source code statements in these programs to be compiled just once, and they will then run on any platform. 2 The study of programming language semantics commenced in the 1960s. It includes work done by Hoare on Axiomatic Semantics; work done by Bjørner and Jones at IBM in Vienna on Opera- tional Semantics; and work done by Scott and Strachey on Denotational Semantics. 3.1 Introduction 75 r Suitable for Business or Scientiﬁc applications r Machine independent r Portability to other platforms r Ease of debugging r Execution speed. These languages are machine independent and may be compiled for different plat- forms. Professional programmers employ these languages to develop almost any type of program. The early 3GLs were procedure-oriented languages that required programmers to solve programming problems by writing the program instructions in the sequence in which they must be executed to solve the problem. The later 3GLs were object-oriented3 and the programming tasks were divided into objects. These objects may be employed to build larger programs, in a manner that is analogous to building a prefabricated building. Examples of modern object-oriented language are the Java language that is used to build web applications, C++ and Smalltalk. High-level programming languages allow programmers to focus on problem solving rather than on the low level details associated with assembly languages. They are easier to debug and easier to maintain than assembly languages. Most of the third generation languages are procedural in that they focus on how something is done rather than on what needs to be done. They include von Neumann constructs such as sequential statements, conditional (or branch) statements, and iterative statements. The fourth generation languages, or 4GLs, are languages that consist of state- ments similar to a human language. Most fourth generation languages are not proce- dural, and are often used in database programming. The term was coined in the early 1980s in a book by James Martin4 [Mar:82]. They specify what needs to be done rather than how it should be done. All 4GLs are designed to reduce programming effort (e.g., reducing the time that to develop the software), as this helps to reduce the cost of software development. However, they are not always successful in this task, and sometimes the resultant code is difﬁcult to maintain. Further, 4GLs are slow when compared to compiled languages. There are various kinds of 4GLs including report generators and form gener- ators. Report generators take a description of the data format and the report that is to be created, and then automatically generate a program to produce the report. Form generators are used to generate programs to manage online interactions with
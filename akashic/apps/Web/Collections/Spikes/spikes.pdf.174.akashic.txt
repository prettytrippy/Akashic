As acquaintance rather than expertise with MatLab is all that is expected of the reader, the  points where mathematically appropriate modifications should be made are generally  contained in statements between two lines of asterisks. This makes it rather easy to find  and make the suggested parameter changes.  Note that many of the scripts provided generate several windows, which MatLab may  plot on top of one another. All windows can be viewed successively by using the Windows  menu, however.  Among the MatLab scripts is a folder entitled 'Basic Scripts'. This contains a very  simple plotting program that will be adequate for any of the earlier problems in the book.  It also contains the basic programs for finding the zeros of a transcendental function as  outlined below.  Three MatLab functions that will be of general utility are fzero(), roots(), and eig().  Their functions are most easily understood through the following examples.  The function fzero() finds the zero of a function that is closest to an initial guess pro- vided by the user. Suppose, for example, that it was necessary to solve the following  transcendental equation:  10  1 +e -.v+5  This type of problem is fairly common in certain neural network formulations. This can  be converted into a form suitable for use with fzero by moving both terms to one side:  10  The left side has been entered into the MatLab function script TransZero.m, which is in  the Basic Scripts folder. The use of fzero to call and solve this function is implemented by  the script Zero Finder.m If this script is run with a range of initial guesses 0<.v<20,  three distinct roots will be found. Fo solve other transcendental equations, TransZero.m  must have the appropriate function entered and must then be saved in the same folder as  Zero_Finder.m.  The roots() function is very simple to use and may be run from the Command window.  It finds the roots of a polynomial expressed as a coefficient vector beginning with the  coefficient of the highest power of the unknown. Suppose you wished to know the roots of  the equation:  5.v3 - 2.v2 + 7 = 0  The coefficient vector in this case would be written in MatLab syntax as [5, -2,0, 7], Note  that every coefficient must be included; the 0 indicates that the coefficient of x is zero.  Typing the command roots([5, -2, 0, 7]) and hitting the carriage return will produce a  listing of the roots, which are -1 and a complex conjugate pair in this case (try it).  Appendix: MatLab™ and the MatLab scripts  289  The eig() function returns the eigenvalues of a square matrix if they exist. In MatLab  syntax, the following matrix:  would be written as: A = [0,1,2; 3,2,1; 1,0,5]. Note that commas separate entries within a  row, while semicolons separate the rows. Now the command eig( A) will generate the three  eigenvalues, the first being -1.2073.  MatLab simulations are described in the chapter where they are first used along with a  brief indication of how they should be used. Frequently one of the chapter figures was  generated by the script being discussed, which should provide a cue to the expected MatLab  results. However, two of the more general and complex scripts deserve brief mention here.  LinearOrder2.m prints out analytical solutions to autonomous, second order homo- geneous linear differential equations for any specified initial conditions. This program  automates the solution of second order equations and will be useful throughout the book.  The user is prompted for the coefficients of the Jacobian matrix and for the initial con- ditions. In the special and highly improbable case where both roots are identical (critical  damping), the solution is printed for x(f) only, on the assumption that the second variable  and initial condition relate to dxjdt. This program should not be modified'by the user. The  program plots both the temporal solutions x(t) and y(t) and the x—y trajectory in the state  space (except for critical damping). The small arrows in the state space plot indicate the  direction of local trajectories throughout the space.  RungeKutta4.m implements a fourth order Runge-Kutta routine with constant step  size for a system of any order. The reader must modify the line indicating the number of  equations N, the time step DT, and the entries in the initial condition vector. Most  importantly, the reader must type in each equation using as variables for the right-hand  side XH(1), XH(2), XH(3),..., XH(N). For example, the FitzHugh-Nagumo equations: 